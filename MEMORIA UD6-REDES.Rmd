---
title: "Resumen UD6; REDES"
author: "Belinda Villalta"
date: "2026-02-03"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

#Servicios de streaming

##Qué es?

###Descarga directa vs Streaming

- Descarga Directa: el usuario demanda un fichero con un peso de
100MB y 10 minutos de duración. Comienza la descarga. Se almacena
en buffer y comienza la reproducción. El usuario termina la
reproducción a los 2 minutos. El servidor ha entregado las 100MB.


- Streaming: Datos enviados en flujo constante. No hay almacenamiento
local permanente. Solo se consume el ancho de banda que el cliente ha
utilizado (2 minutos según el ejemplo anterior). 



##Topología de red

###Unicast: conexión 1 a 1 (estándar de internet)

- Mecánica: Si hay 100 oyentes, el servidor abre 100 sockets TCP y envía
la información 100 veces.

- Cálculo de Ancho de Banda: BW(tot) = BW(stream) x N(usuarios)

- Desventaja: Poco escalable.

##Multicast:

- Mecánica: El servidor envía la información a una dirección multicast
(224.0.0.0 - 239.255.255.255). Routers replican el paquete solo si
tienen suscriptores.

- Desventaja: Routers bloquean paquetes multicast. Solo viable en redes
internas. 

###QoS: Jitter, Buffer

##Jitter (Fluctuación)

Es la variación en el tiempo de llegada de los paquetes.

- Ejemplo: El paquete 1 tarda 20ms, el paquete 2 tarda 150ms, el paquete 3 tarda
20ms.

- Si el Jitter es superior al tamaño del buffer, el audio se corta (Buffer Underrun).

##Buffer (Amortiguador)

Es una memoria temporal en el cliente (y en el servidor).

- Función: Acumular suficientes segundos de audio para absorber el Jitter de la red.

- Efecto: A mayor buffer → Mayor estabilidad → Mayor latencia (retraso).


##Burst-on-Connect (Ráfaga de conexión)

Una característica específica de servidores como Icecast.

- Problema: Al conectarse, el oyente tardaría varios segundos en llenar
su buffer a velocidad normal (1x).

- Solución (Burst): El servidor envía los datos iniciales (ej. 64KB) a la
máxima velocidad posible que permita la red (ej. 10x), llenando el
buffer del cliente casi instantáneamente para que el audio empiece a
sonar de inmediato (Time-to-first-byte reducido).


###Protocolos de Streaming

##1. Capa de transporte: TCP vs UDP
En TCP si un paquete de audio/vídeo se pierde, el cliente no lo
reproduce y por tanto el servidor lo reenvía (ACK/NACK).
La ventaja es evidente: calidad y pasa sin problemas por firewalls, NAT
y proxy al usar puertos estándar.
La desventaja también es evidente: alta latencia. La retransmisión de
paquetes introduce retraso.
En UDP sacrificamos calidad pero latencia mínima. 

TODO AUDIO/VIDEO NO ES UDP


##2. Capa de aplicación (tres modelos):

1. HTTP Legacy (como usa Icecast2 - lo veremos más adelante)
2. HTTP Adaptativo
3. Real-time

###Protocolos de Streaming

##HTTP Legacy (como usa Icecast2 - lo veremos más adelante)

● Protocolo: ICY

● Mecánica: se abre conexión TCP y el servidor envía flujo de datos sin parar hasta
que el cliente cierra la conexión.

● Puertos: 80. 443, 8000 (Icecast2)

● Formato: flujo continuo de bytes (MP3, Ogg, ACC).

##HTTP Adapatitivo

● Protocolos: HLS (HTTP Live Streaming de Apple) - MPEG-DASH.

● Mecánica: no es flujo continuo. El servidor trocea el fichero en pequeños trozos
(chunks) de 2 a 10 segundos.

● Formato: .ts, .m4s.

● Pro: calidad adaptativa. El servidor envía un Manifest con el que da la opción a
descargar un chunk de mejor o peor calidad. 

##Real-Time

● RTMP (Real-Time Messaging Protocol): funciona sobre TCP. Está
obsoleto para usuario final pero se usa para enviar vídeo al servidor
(por ejemplo de OBS a YT/Twitch).

● RTSP (Real-Time Streaming Protocol): usado en cámaras de seguridad
(CCTV) y sistemas domóticos. Generalmente usa UDP para datos y
TCP para control.

● WebRTC: para videoconferencia. P2P, cifrado, UDP, funciona en
navegador sin plugins (Google Meet, Discord). 


This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
